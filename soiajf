use std::borrow::Cow;
use std::str::FromStr;
use rand::seq::SliceRandom;
use rand::Rng;


#[test]
pub fn test1() {
    let mut rng = rand::thread_rng();

    let mut names = Vec::new();
    for _ in 0 .. 10000 {
        let mut content = [0u8; 20];
        let len = rng.gen_range(0 .. 20);
        for idx in 0 .. len {
            content[idx as usize] = rng.gen_range(0 .. db::Username::CHARS.len() as u8);
        }
        let name = unsafe { db::Username::from_raw(len, content) };
        if !names.contains(&name) {
            names.push(name);
        }
    }

    for _ in 0 .. 2 {
        let mut db = unsafe { db::Value::create("test_db") }.unwrap();
        let t = std::time::Instant::now();
        for name in &names {
            // let len = rng.gen_range(1u8 ..= 20);
            

            // use rand::distributions::{Alphanumeric, DistString};

            // let len = rng.gen_range(0 .. 20);
            // let status = Alphanumeric.sample_string(&mut rng, len);

            let user = db::user::Value {
                name: name.clone(),
                id: 55555,
                scratch_team: rng.r#gen(),
                status: Cow::Owned("I".to_string()),
                bio: Cow::Borrowed("Amazing bio!")
            };
            db.add_user(user).unwrap();
        }
        println!("write ms: {}", t.elapsed().as_millis());

        let t = std::time::Instant::now();
        for name in &names {
            let user = db.user_by_name(name).unwrap();
            assert_eq!(&user.name, name);
        }
        println!("get ms: {}", t.elapsed().as_millis());

        let t = std::time::Instant::now();
        for name in &names {
            if db.remove_user_by_name(name).unwrap() {
                panic!("Name didn't exist!");
            }
        }
        println!("Remove free locations: {}", db.users.free_locations_len());
        println!("remove ms: {}", t.elapsed().as_millis());

        for name in &names {
            assert!(db.user_by_name(name).is_none());
        }
    }
}


// impl binbuf::Dynamic for DbValue {
//     fn buf_len(buf: binbuf::dynamic::BufConst<Self>) -> usize {
//         unsafe {
//             let mut cursor = FixedData::LEN;
//             cursor += binbuf::dynamic::ptr_len::<BytesPtrConst>(buf.0.range_from(cursor));
//             cursor += binbuf::dynamic::ptr_len::<BytesPtrConst>(buf.0.range_from(cursor));
//             cursor
//         }
//     }

//     fn len(&self) -> usize {
//         FixedData::LEN
//         + <BytesPtrConst as binbuf::Dynamic>::len(&self.status)
//         + <BytesPtrConst as binbuf::Dynamic>::len(&self.bio)
//     }

//     fn encode(&self, buf: binbuf::dynamic::BufMut<Self>) -> usize {
//         unsafe {
//             let mut cursor = binbuf::dynamic::encode_ptr(buf.0, &self.fixed_data);
//             cursor += binbuf::dynamic::encode_ptr(buf.0.range_from(cursor), &self.status);
//             cursor += binbuf::dynamic::encode_ptr(buf.0.range_from(cursor), &self.bio);
//             cursor
//         }
//     }
// }

// impl binbuf::dynamic::Decode for DbValue {
//     fn decode(buf: binbuf::dynamic::BufConst<Self>) -> (Self, usize) {
//         unsafe {
//             let (fixed_data, mut cursor) = binbuf::dynamic::decode_ptr(buf.0);
//             let (status, mut l) = binbuf::dynamic::decode_ptr(buf.0.range_from(cursor));
//             cursor += l;
//             let (bio, mut l) = binbuf::dynamic::decode_ptr(buf.0.range_from(cursor));
//             cursor += l;
//             (Self { fixed_data, status, bio }, cursor)
//         }
//     }
// }
